import { GasReporterOptions, JsonRpcTx } from "../types";
/**
==========================
OPTIMISM BEDROCK
==========================
Given:

+ A fixed overhead cost for publishing a transaction (currently set to 188 gas).
+ A dynamic overhead cost which scales with the size of the transaction (currently set to 0.684).

Count the number of zero bytes and non-zero bytes in the transaction data. Each zero byte
costs 4 gas and each non-zero byte costs 16 gas.
```
tx_data_gas = count_zero_bytes(tx_data) * 4 + count_non_zero_bytes(tx_data) * 16
tx_total_gas = (tx_data_gas + fixed_overhead) * dynamic_overhead
l1_data_fee = tx_total_gas * ethereum_base_fee
```
Source: https://docs.optimism.io/stack/transactions/fees#formula
*/
/**
 * Gets calldata gas plus overhead for a tx (an input into the function below)
 * @param tx        JSONRPC formatted getTransaction response
 * @returns
 */
export declare function getOptimismBedrockL1Gas(tx: JsonRpcTx): number;
/**
 * Gets the native token denominated cost of registering tx calldata to L1
 * @param txDataGas            amount obtained from `getOptimismBedrockL1Gas`
 * @param baseFee              amount obtained from previous block
 * @returns
 */
export declare function getOptimismBedrockL1Cost(txDataGas: number, baseFee: number): number;
/**
 * Gets transaction calldata gas usage (an input into the cost function below)
 * @param tx    JSONRPC formatted getTransaction response
 * @returns
 */
export declare function getOptimismEcotoneL1Gas(tx: JsonRpcTx): number;
/**
 * Gets the native token denominated cost of registering tx calldata to L1
 * @param txCompressed
 * @param baseFee
 * @param blobBaseFee
 * @returns
 *
 * Source: https://github.com/ethereum-optimism/optimism/blob/e57787ea7d0b9782cea5f32bcb92d0fdeb7bd870/ +
 *         packages/contracts-bedrock/src/L2/GasPriceOracle.sol#L88-L92
 *
 * DECIMALS = 6
 *
 * function _getL1FeeEcotone(bytes memory _data) internal view returns (uint256) {
 *       uint256 l1GasUsed = _getCalldataGas(_data);
 *       uint256 scaledBaseFee = baseFeeScalar() * 16 * l1BaseFee();
 *       uint256 scaledBlobBaseFee = blobBaseFeeScalar() * blobBaseFee();
 *       uint256 fee = l1GasUsed * (scaledBaseFee + scaledBlobBaseFee);
 *       return fee / (16 * 10 ** DECIMALS);
 *   }
 */
export declare function getOptimismEcotoneL1Cost(txSerialized: number, baseFee: number, blobBaseFee: number): number;
export declare function getArbitrum_OS11_L1Gas(tx: JsonRpcTx): number;
export declare function getArbitrum_OS20_L1Gas(tx: JsonRpcTx): number;
export declare function getArbitrum_OS11_L1Cost(gas: number): number;
export declare function getArbitrum_OS20_L1Cost(gas: number): number;
/**
 * Computes the amount of L1 gas used for a transaction. The overhead represents the per batch
 * gas overhead of posting both transaction and state roots to L1 given larger batch sizes.
 *
 *  4   gas for 0 byte
 * 16   gas for non zero byte
 *
 * Account for the transaction being unsigned. Padding is added to account for lack of signature
 * on transaction.  (Assume VRS components are non-zero)
 *
 *         1   byte for RLP V prefix
 *         1   byte for V
 *         1   byte for RLP R prefix
 *        32   bytes for R
 *         1   byte for RLP S prefix
 *        32   bytes for S
 * ----------
 * Total: 68   bytes of padding
 *
 * SOURCE: optimism/packages/contracts/contracts/L2/predeploys/OVM_GasPriceOracle.sol
 */
export declare function getSerializedTxDataGas(tx: JsonRpcTx): number;
/**
 * Computes the intrinsic gas overhead for the data component of a transaction
 * @param data
 * @returns
 */
export declare function getCalldataBytesGas(data: string): number;
/**
 * Returns estimate of the intrinsic gas used for executing a tx on L1 EVM;
 * @param tx
 * @returns
 */
export declare function getIntrinsicGas(data: string): number;
/**
 * Returns gas cost minus the intrinsic gas call overhead for a transaction
 * @param data
 * @param gas
 * @returns
 */
export declare function getGasSubIntrinsic(data: string, gas: number): number;
/**
 * Gets calldata gas amount for network by hardfork
 * @param options      GasReporterOptions
 * @param tx           JSONRPC formatted transaction
 * @returns
 */
export declare function getCalldataGasForNetwork(options: GasReporterOptions, tx: JsonRpcTx): number;
/**
 * Gets calldata gas X gas price for network by hardfork
 * @param options        GasReporterOptions
 * @param gas            Scaled gas value collected
 * @param baseFee        Network fee from block
 * @param blobBaseFee    Network fee from block
 * @returns
 */
export declare function getCalldataCostForNetwork(options: GasReporterOptions, gas: number): number;
/**
 * Expresses gas usage as a nation-state currency price
 * @param  {Number} executionGas      execution gas used
 * @param  {Number} calldataGas       data gas used
 * @param  {GasReporterOptions}       options
 * @return {string}                   cost of gas used "0.00"
 */
export declare function gasToCost(executionGas: number, calldataGas: number, options: GasReporterOptions): string;
/**
 * Expresses gas usage as a % of the block gasLimit. Source: NeuFund (see issues)
 * @param  {Number} gasUsed    gas value
 * @param  {Number} blockLimit gas limit of a block
 * @return {Number}            percent (0.0)
 */
export declare function gasToPercentOfLimit(gasUsed: number, blockLimit: number): number;
/**
 * Converts hex to decimal
 * @param  {string}     hex JSONRPC val
 * @return {Number}     decimal
 */
export declare function hexToDecimal(val: string): number;
/**
 * Converts hex to bigint
 * @param  {string}     hex JSONRPC val
 * @return {BigInt}     bigint
 */
export declare function hexToBigInt(val: string): bigint;
export declare function hexWeiToIntGwei(val: string): number;
export declare function normalizeTxType(_type: string): ("legacy" | "eip1559" | "eip2930" | "eip4844");
//# sourceMappingURL=gas.d.ts.map